<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HEBench: Quickstart C++ Wrapper Backend Tutorial - Benchmark Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEBench
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('be_tutorial_impl_palisade.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Quickstart C++ Wrapper Backend Tutorial - Benchmark Implementation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md37">Communication between Pipeline Stages</a></li>
<li class="level1"><a href="#autotoc_md38">Mapping Workflow to API Bridge Pipeline</a></li>
<li class="level1"><a href="#autotoc_md39">Steps</a><ul><li class="level2"><a href="#autotoc_md40">0. Benchmark Initialization</a></li>
<li class="level2"><a href="#autotoc_md41">1. encode</a></li>
<li class="level2"><a href="#autotoc_md42">2. encrypt</a></li>
<li class="level2"><a href="#autotoc_md43">3. load</a></li>
<li class="level2"><a href="#autotoc_md44">4. operate</a></li>
<li class="level2"><a href="#autotoc_md45">5. store</a></li>
<li class="level2"><a href="#autotoc_md46">6. decrypt</a></li>
<li class="level2"><a href="#autotoc_md47">7 decode</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md48">Tutorial steps</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_docsrc_examples_backend_tutorials_palisade_backend_tutorial_impl_palisade"></a></p>
<p>The previous steps were all about getting the new backend project, engine, and benchmark description setup to run. Now we need to actually implement our benchmark logic by implementing each of the 7 virtual functions defined in <code><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html" title="Top level opaque benchmark class.">hebench::cpp::BaseBenchmark</a></code> which map to the <code><a class="el" href="namespacehebench_1_1APIBridge.html">hebench::APIBridge</a></code> backend interface. For this example, we will go over each function and provide an overview of what that function needs to do and the tutorial implemention using PALISADE.</p>
<p>We already have our original workflow that executes the element-wise addition operation, and we want to benchmark, as shown during the introduction. To write our test into HEBench, we must understand the detailed workload description. All supported workloads can be found at <a class="el" href="tests_overview.html">HEBench Supported Workloads</a> . In particular, <a class="el" href="elementwise_add.html">Vector Element-wise Addition Workload</a> contains the detailed information for our workload, including number, format, and layout of the parameters; a detailed description of the benchmarks algorithm and how each of the previously described parameters are used; and the expected format and data layout of the benchmark input and results.</p>
<h1><a class="anchor" id="autotoc_md37"></a>
Communication between Pipeline Stages</h1>
<p>Benchmarks are required to implement a number of functions as defined in the API Bridge. These functions are called by the frontend as part of the testing procedure. Each function will receive some parameters as input, perform some expected operation, and then pass the results back to the frontend which will use the returned results as input to later functions in the flow. This logical flow must be respected by the different functions we have to implement.</p>
<div align="center"> <img src="function_pipeline.png" alt="" width="750" class="inline"/><br  />
 <span>API Bridge Function pipeline flow chart.</span> </div><p>For more information on the pipeline flow, check <a class="el" href="function_pipeline_chart.html">API Bridge Function Pipeline Chart</a> .</p>
<p>To enable a high amount of flexibility and enable the widest variety of implementations with the exception of the encode and decode's <code><a class="el" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPackCollection" title="Defines a collection of data packs.">hebench::APIBridge::DataPackCollection</a></code> parameters, all communication is done via <code><a class="el" href="namespacehebench_1_1APIBridge.html#a1cc432e69cd60c216161fae560d8a6f4" title="Encapsulates an opaque handle to backend data.">hebench::APIBridge::Handle</a> objects</code>. These handle objects are completely opaque to the Test Harness and it is up to the backend to decide what is stored in each handle at each step of the pipeline.</p>
<p>C++ wrapper offers a series of helper methods to ease the creation and data wrapping in these handles. While it is not necessary to use these methods, it is recommended for code correctness, robustness, and clarity. See <code><a class="el" href="classhebench_1_1cpp_1_1BaseEngine.html#a1bee837f9a3b7ac50ff1b65ad0a415f5" title="Encapsulates an object of type T in an opaque HEBench handle.">hebench::cpp::BaseEngine::createHandle()</a></code> and <code><a class="el" href="classhebench_1_1cpp_1_1BaseEngine.html#a1951e5a864ad7699fd30a062b7e9576d" title="Retrieves the object of type T encapsulated in an opaque HEBench handle by method createHandle().">hebench::cpp::BaseEngine::retrieveFromHandle()</a></code> for details.</p>
<p>All the methods that will be called from Test Harness should receive validated inputs and C++ wrapper performs some basic validation as well (such as null handle checks); however, it is a good idea to validate those inputs in the case where we are using incompatible versions between Test Harness and our backend's required API Bridge, or any other errors occur. For clarity, though, most validation will be omitted in this tutorial (or handled with an <code>assert</code> call).</p>
<p>Always throw <code><a class="el" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a></code> from C++ wrapper to report errors. C++ wrapper will understand this error type and inform Test Harness accordingly. Throwing other exceptions is valid, but they result in Test Harness receiving <code>HEBENCH_ECODE_CRITICAL_ERROR</code> from the backend. There are some examples throughout the tutorial code.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Mapping Workflow to API Bridge Pipeline</h1>
<p>Our task is to map our workflow to the stages of the API Bridge pipeline (each function in the flow graph).</p>
<p>In our example, we already have a workflow that is easy to map, since we have organized stages into function calls. We copy our workflow declaration into the benchmark class (with some extra helper methods) as shown here:</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="keyword">class </span><a class="code" href="namespacehebench_1_1APIBridge.html#aeb7e1cd988a3ca98e5345d5bc90aa733">Workload</a></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    {</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <a class="code" href="namespacehebench_1_1APIBridge.html#aeb7e1cd988a3ca98e5345d5bc90aa733">Workload</a>(std::size_t vector_size);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160; </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        std::vector&lt;lbcrypto::Plaintext&gt; encodeVector(<span class="keyword">const</span> std::vector&lt;std::vector&lt;std::int64_t&gt;&gt; &amp;vec);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; encryptVector(<span class="keyword">const</span> std::vector&lt;lbcrypto::Plaintext&gt; &amp;encoded_vec);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; eltwiseadd(<span class="keyword">const</span> std::vector&lt;lbcrypto::Plaintext&gt; &amp;A,</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                                                                         <span class="keyword">const</span> std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;B);</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        std::vector&lt;lbcrypto::Plaintext&gt; decryptResult(<span class="keyword">const</span> std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;encrypted_result);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        std::vector&lt;std::vector&lt;int64_t&gt;&gt; decodeResult(<span class="keyword">const</span> std::vector&lt;lbcrypto::Plaintext&gt; &amp;encoded_result);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160; </div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keyword">private</span>:</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="keyword">class </span>PalisadeBFVContext</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keyword">public</span>:</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            PalisadeBFVContext(<span class="keywordtype">int</span> poly_modulus_degree);</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160; </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="keyword">auto</span> publicKey()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_keys-&gt;publicKey; }</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            std::size_t getSlotCount()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_slot_count; }</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            lbcrypto::CryptoContext&lt;lbcrypto::DCRTPoly&gt; &amp;context() { <span class="keywordflow">return</span> *m_p_palisade_context; }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <span class="keywordtype">void</span> <a class="code" href="namespacehebench_1_1APIBridge.html#a563432d24c94d7b3fdb902a9d2c1e1c3">decrypt</a>(<span class="keyword">const</span> lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt; &amp;cipher, lbcrypto::Plaintext &amp;plain)</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                context()-&gt;Decrypt(m_keys-&gt;secretKey, cipher, &amp;plain);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            }</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160; </div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            lbcrypto::Plaintext <a class="code" href="namespacehebench_1_1APIBridge.html#a563432d24c94d7b3fdb902a9d2c1e1c3">decrypt</a>(<span class="keyword">const</span> lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt; &amp;cipher)</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                lbcrypto::Plaintext retval;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                <a class="code" href="namespacehebench_1_1APIBridge.html#a563432d24c94d7b3fdb902a9d2c1e1c3">decrypt</a>(cipher, retval);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            }</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160; </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keyword">private</span>:</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            std::shared_ptr&lt;lbcrypto::CryptoContext&lt;lbcrypto::DCRTPoly&gt;&gt; m_p_palisade_context;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            std::unique_ptr&lt;lbcrypto::LPKeyPair&lt;lbcrypto::DCRTPoly&gt;&gt; m_keys;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            std::size_t m_slot_count;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        };</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160; </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        std::size_t m_vector_size;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        std::shared_ptr&lt;PalisadeBFVContext&gt; m_p_context;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160; </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        PalisadeBFVContext &amp;context() { <span class="keywordflow">return</span> *m_p_context; }</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    };</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a563432d24c94d7b3fdb902a9d2c1e1c3"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a563432d24c94d7b3fdb902a9d2c1e1c3">hebench::APIBridge::decrypt</a></div><div class="ttdeci">ErrorCode decrypt(Handle h_benchmark, Handle h_ciphertext, Handle *h_plaintext)</div><div class="ttdoc">Decrypts a cipher text into corresponding plain text.</div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_aeb7e1cd988a3ca98e5345d5bc90aa733"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#aeb7e1cd988a3ca98e5345d5bc90aa733">hebench::APIBridge::Workload</a></div><div class="ttdeci">Workload</div><div class="ttdoc">Defines all possible workloads.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00082">types.h:83</a></div></div>
</div><!-- fragment --><p> We also define some wrappers as internal representation for the parameters to our workflow methods. These are needed to keep track and retrieve the inputs and outputs of the stages as they are wrapped into opaque handles.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keyword">struct </span>InternalParamInfo</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keyword">static</span> constexpr std::int64_t tagPlaintext  = 0x10;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keyword">static</span> constexpr std::int64_t tagCiphertext = 0x20;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        std::uint64_t param_position;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        std::int64_t tag;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    };</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="comment">// used to bundle a collection of samples for an operation parameter</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keyword">struct </span>InternalParam : <span class="keyword">public</span> InternalParamInfo</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        std::vector&lt;T&gt; samples;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    };</div>
</div><!-- fragment --><p> The next steps follow the logical flow order of the function pipeline.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Steps</h1>
<h2><a class="anchor" id="autotoc_md40"></a>
0. Benchmark Initialization</h2>
<p>During construction of our actual benchmark class, <code>TutorialEltwiseAddBenchmark</code>, we validate the workload flexible parameters that were passed for this benchmark. These must be checked because users can use benchmark configuration files to pass different parameters.</p>
<p>Afterwards, other benchmark initialization steps are performed. In this case, we are initializing our original workflow and the PALISADE context for our operations.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;TutorialEltwiseAddBenchmark::TutorialEltwiseAddBenchmark(<a class="code" href="classhebench_1_1cpp_1_1BaseEngine.html">hebench::cpp::BaseEngine</a> &amp;engine,</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                                                         <span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1BenchmarkDescriptor">hebench::APIBridge::BenchmarkDescriptor</a> &amp;bench_desc,</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                                                         <span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1WorkloadParams">hebench::APIBridge::WorkloadParams</a> &amp;bench_params) :</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <a class="code" href="namespacehebench.html">hebench</a>::cpp::BaseBenchmark(engine, bench_desc, bench_params)</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;{</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="comment">// validate workload parameters</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160; </div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="comment">// number of workload parameters (1 for eltwise add: n)</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="keywordflow">if</span> (bench_params.<a class="code" href="namespacehebench_1_1APIBridge.html#a3d9134d91c8bd656bbfb21cbd5ab5342">count</a> &lt; TutorialEltwiseAddBenchmarkDescription::NumWorkloadParams)</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(<span class="stringliteral">&quot;Invalid workload parameters. This workload requires &quot;</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                                                            + <a class="code" href="namespacehebench_1_1ReportGen.html#a3719b248760816f6342f9f769d4ac2f5">std::to_string</a>(TutorialEltwiseAddBenchmarkDescription::NumWorkloadParams)</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                                                            + <span class="stringliteral">&quot;parameters.&quot;</span>),</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                                         <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160; </div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="comment">// check values of the workload parameters and make sure they are supported by benchmark:</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <a class="code" href="classhebench_1_1cpp_1_1WorkloadParams_1_1VectorSize.html">hebench::cpp::WorkloadParams::EltwiseAdd</a> w_params(bench_params);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="keywordflow">if</span> (w_params.n() &lt;= 0</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        || w_params.n() - 1 &gt; TutorialEltwiseAddBenchmarkDescription::PolyModulusDegree / 2)</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(<span class="stringliteral">&quot;Invalid workload parameters. This workload only supports vectors of size up to &quot;</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                                                            + <a class="code" href="namespacehebench_1_1ReportGen.html#a3719b248760816f6342f9f769d4ac2f5">std::to_string</a>(TutorialEltwiseAddBenchmarkDescription::PolyModulusDegree / 2)),</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                                         <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160; </div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="comment">// Do any extra workload-parameter-based initialization here, if needed.</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160; </div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="comment">// initialize original Workload (this initializes PALISADE BFV context)</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    m_p_workload = std::make_shared&lt;Workload&gt;(w_params.n());</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;}</div>
<div class="ttc" id="aclasshebench_1_1cpp_1_1BaseEngine_html"><div class="ttname"><a href="classhebench_1_1cpp_1_1BaseEngine.html">hebench::cpp::BaseEngine</a></div><div class="ttdoc">Base class that encapsulates common behavior of backend engines.</div><div class="ttdef"><b>Definition:</b> <a href="engine_8hpp_source.html#l00069">engine.hpp:70</a></div></div>
<div class="ttc" id="aclasshebench_1_1cpp_1_1HEBenchError_html"><div class="ttname"><a href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a></div><div class="ttdef"><b>Definition:</b> <a href="error__handling_8hpp_source.html#l00024">error_handling.hpp:25</a></div></div>
<div class="ttc" id="aclasshebench_1_1cpp_1_1WorkloadParams_1_1VectorSize_html"><div class="ttname"><a href="classhebench_1_1cpp_1_1WorkloadParams_1_1VectorSize.html">hebench::cpp::WorkloadParams::VectorSize</a></div><div class="ttdef"><b>Definition:</b> <a href="workload__params_8hpp_source.html#l00309">workload_params.hpp:310</a></div></div>
<div class="ttc" id="aerror__handling_8hpp_html_a9d8a8027ac0dfd443d0b8d000f86c30d"><div class="ttname"><a href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a></div><div class="ttdeci">#define HEBERROR_MSG_CLASS(message)</div><div class="ttdef"><b>Definition:</b> <a href="error__handling_8hpp_source.html#l00016">error_handling.hpp:16</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a3d9134d91c8bd656bbfb21cbd5ab5342"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a3d9134d91c8bd656bbfb21cbd5ab5342">hebench::APIBridge::WorkloadParams::count</a></div><div class="ttdeci">std::uint64_t count</div><div class="ttdoc">Number of workload parameters.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00371">types.h:371</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_structhebench_1_1APIBridge_1_1BenchmarkDescriptor"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1BenchmarkDescriptor">hebench::APIBridge::BenchmarkDescriptor</a></div><div class="ttdoc">Defines a benchmark test.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00526">types.h:527</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_structhebench_1_1APIBridge_1_1WorkloadParams"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1WorkloadParams">hebench::APIBridge::WorkloadParams</a></div><div class="ttdoc">Specifies the parameters for a workload.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00362">types.h:363</a></div></div>
<div class="ttc" id="anamespacehebench_1_1ReportGen_html_a3719b248760816f6342f9f769d4ac2f5"><div class="ttname"><a href="namespacehebench_1_1ReportGen.html#a3719b248760816f6342f9f769d4ac2f5">hebench::ReportGen::to_string</a></div><div class="ttdeci">std::string to_string(const std::string_view &amp;s)</div><div class="ttdef"><b>Definition:</b> <a href="hebench__report__impl_8cpp_source.html#l00018">hebench_report_impl.cpp:18</a></div></div>
<div class="ttc" id="anamespacehebench_html"><div class="ttname"><a href="namespacehebench.html">hebench</a></div><div class="ttdef"><b>Definition:</b> <a href="hebench__benchmark__category_8h_source.html#l00018">hebench_benchmark_category.h:18</a></div></div>
<div class="ttc" id="atypes_8h_html_abba732801d5a4a4d7608505eebddf434"><div class="ttname"><a href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a></div><div class="ttdeci">#define HEBENCH_ECODE_INVALID_ARGS</div><div class="ttdoc">Indicates invalid arguments to function call.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00042">types.h:42</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md41"></a>
1. encode</h2>
<p><b><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html#a528cdfda8c810cf3d9eac4cd3bf1f0e1">hebench::cpp::BaseBenchmark::encode</a></b> wraps the <code><a class="el" href="namespacehebench_1_1APIBridge.html#a4fc50bea04798d1baf8dbad8359f8f10" title="Given a pack of parameters in raw, native data format, encodes them into plain text suitable for back...">hebench::APIBridge::encode()</a></code> function. In the default behavior: encode receives a call for all operation parameters that will be in plain text, and another call for all encrypted, in no specific order. This method should encode all parameters received via <code>p_parameters</code>, bundle them together using an internal format that will make easier to recover from other methods (such as encrypt and/or load) and return them in an opaque handle.</p>
<p>Encode is responsible for rearranging and encoding this data into a format and new memory location that is compatible with the backend.</p>
<div align="center"> <img src="apibridge_encode_diagram.png" alt="" width="700" class="inline"/><br  />
 <span>API Bridge Encode flow chart.</span> </div><p>For our benchmark, the element-wise add operation has only 2 operands. We have specified in the benchmark description that first is plain text and second is ciphertext. According to documentation, Test Harness will encode all parameters that ought to be encrypted in a single call to encode, and all the plain text in another call.</p>
<p>First, we validate the data packs. Our backend supports variable sample sizes, but since we are specifying hard values for number of samples per parameter in the benchmark description, we make sure we are receiving the correct number of samples here. We can set the specified count to <code>0</code> in the description and accept variable number of samples instead.</p>
<div class="fragment"><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPack">hebench::APIBridge::DataPack</a> &amp;param_pack = p_parameters-&gt;p_data_packs[0];</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160; </div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">if</span> (param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a> != this-&gt;getDescriptor().cat_params.offline.data_count[param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a>])</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    {</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        std::stringstream ss;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;Unexpected number of input samples for operation parameter &quot;</span> &lt;&lt; param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;           &lt;&lt; <span class="stringliteral">&quot;. Expected &quot;</span> &lt;&lt; this-&gt;getDescriptor().cat_params.offline.data_count[param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a>]</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;           &lt;&lt; <span class="stringliteral">&quot;, but &quot;</span> &lt;&lt; <a class="code" href="namespacehebench_1_1ReportGen.html#a3719b248760816f6342f9f769d4ac2f5">std::to_string</a>(param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a>) &lt;&lt; <span class="stringliteral">&quot; received.&quot;</span>;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(ss.str()));</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    }</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_aa570c2b9dd82ecea6967aaaac4f83149"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">hebench::APIBridge::DataPack::param_position</a></div><div class="ttdeci">std::uint64_t param_position</div><div class="ttdoc">The 0-based position of this parameter in the corresponding function call.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00614">types.h:614</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_acf775f3fb5a78d09c32232b1a984587d"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">hebench::APIBridge::DataPack::buffer_count</a></div><div class="ttdeci">std::uint64_t buffer_count</div><div class="ttdoc">Number of data buffers in p_buffers.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00613">types.h:613</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_structhebench_1_1APIBridge_1_1DataPack"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPack">hebench::APIBridge::DataPack</a></div><div class="ttdoc">Defines a data package for an operation.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00610">types.h:611</a></div></div>
</div><!-- fragment --><p> Once we know the data pack is valid, we must arrange the raw data coming from Test Harness to be compatible with the input to our original encoding method. In offline category, each operation parameter contains a collection of samples for said parameter. Since the incoming data which is already in the expected format for our original encoding, we just have to point the data structures to the appropriate memory locations. Refer to the workload description reference for information on the data layouts.</p>
<p>Each sample coming from Test Harness is contained in a memory buffer wrapped in a <code><a class="el" href="namespacehebench_1_1APIBridge.html#aeafdcf7ee09cebcc8d7c8288103cc9ed" title="Represents a native data buffer maintained by the Test Harness.">hebench::APIBridge::NativeDataBuffer</a></code> structure. A sample for element-wise add is a vector of scalars of the requested type during benchmark description (64-bit signed integer in this example). The number of elements in this vector should be the same as received from the workload parameters during construction of this object.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    std::vector&lt;std::vector&lt;std::int64_t&gt;&gt; clear_param(param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a>);</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160; </div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keywordflow">for</span> (std::size_t sample_i = 0; sample_i &lt; clear_param.size(); ++sample_i)</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    {</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::NativeDataBuffer</a> &amp;native_sample = param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#adec71d611d0a215a74548000bae9aeff">p_buffers</a>[sample_i];</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keyword">const</span> std::int64_t *start_pt                              = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::int64_t *<span class="keyword">&gt;</span>(native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#aaa0145d02cf5ae07a0fa583b5be8de47">p</a>);</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keyword">const</span> std::int64_t *end_pt                                = start_pt + native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#a9ef01b822fa75f3841657abbed013c01">size</a> / <span class="keyword">sizeof</span>(std::int64_t);</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        clear_param[sample_i]                                     = std::vector&lt;std::int64_t&gt;(start_pt, end_pt);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a9ef01b822fa75f3841657abbed013c01"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a9ef01b822fa75f3841657abbed013c01">hebench::APIBridge::_FlexibleData::size</a></div><div class="ttdeci">std::uint64_t size</div><div class="ttdoc">Size of underlying data.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00564">types.h:564</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_aaa0145d02cf5ae07a0fa583b5be8de47"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#aaa0145d02cf5ae07a0fa583b5be8de47">hebench::APIBridge::_FlexibleData::p</a></div><div class="ttdeci">void * p</div><div class="ttdoc">Pointer to underlying data.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00558">types.h:558</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_adec71d611d0a215a74548000bae9aeff"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#adec71d611d0a215a74548000bae9aeff">hebench::APIBridge::DataPack::p_buffers</a></div><div class="ttdeci">NativeDataBuffer * p_buffers</div><div class="ttdoc">Array of data buffers for parameter.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00612">types.h:612</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_structhebench_1_1APIBridge_1_1__FlexibleData"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::_FlexibleData</a></div><div class="ttdoc">Structure to contain flexible data.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00551">types.h:552</a></div></div>
</div><!-- fragment --><p> Since we arranged the input from Test Harness into the format expected by our original encoding method, now we get to call it to do our actual encoding.</p>
<div class="fragment"><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    std::vector&lt;lbcrypto::Plaintext&gt; encoded = m_p_workload-&gt;encodeVector(clear_param);</div>
</div><!-- fragment --><p> From the default pipeline, the result of the encoding will be passed to <code><a class="el" href="namespacehebench_1_1APIBridge.html#a0487699ebe2558d978890e5effd1e016" title="Encrypts a plain text into a cipher text.">encrypt()</a></code> or <code><a class="el" href="namespacehebench_1_1APIBridge.html#ac4d8486aa63649beac1378e8fa8baf3c" title="Loads the specified data from the local host into the remote backend to use as parameter during a cal...">load()</a></code> methods, which correspond to our workflow encryption and (for lack of load step) operation. So, to return the encoding, we wrap it in our internal representation. This representation can be as simple or as sophisticated as we want. The idea is to facilitate access to the wrapped data by methods that will be receiving it.</p>
<p>Then, we hide our representation inside an opaque handle to cross the boundary of the API Bridge. We use <code><a class="el" href="classhebench_1_1cpp_1_1BaseEngine.html" title="Base class that encapsulates common behavior of backend engines.">hebench::cpp::BaseEngine</a>:: createHandle()</code> helper method to generate the handle for our return value.</p>
<p>The tag serves to keep track and identify that we are receiving the correct handles in the pipeline. The values for the tag are arbitrary, for backend to use for this purpose, and thus, we define an internal convention for tagging our handles.</p>
<p>We use move semantics when creating the handle to avoid copying possibly large amounts of data here. But, again, this is all backend specific, and any particular implementation is free to return the data in whichever way fits best.</p>
<div class="fragment"><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    InternalParam&lt;lbcrypto::Plaintext&gt; retval;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    retval.samples        = std::move(encoded);</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    retval.param_position = param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a>;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    retval.tag            = InternalParamInfo::tagPlaintext;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160; </div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">return</span> this-&gt;getEngine().template createHandle&lt;decltype(retval)&gt;(</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="keyword">sizeof</span>(lbcrypto::Plaintext) * retval.samples.size(), <span class="comment">// size (arbitrary for our usage if we need to)</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        retval.tag, <span class="comment">// extra tags</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        std::move(retval)); <span class="comment">// constructor parameters</span></div>
</div><!-- fragment --><p> This is the complete listing of our <code><a class="el" href="namespacehebench_1_1APIBridge.html#a4fc50bea04798d1baf8dbad8359f8f10" title="Given a pack of parameters in raw, native data format, encodes them into plain text suitable for back...">encode()</a></code> method:</p>
<div class="fragment"><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> <a class="code" href="namespacehebench_1_1APIBridge.html#a4fc50bea04798d1baf8dbad8359f8f10">TutorialEltwiseAddBenchmark::encode</a>(<span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPackCollection">hebench::APIBridge::DataPackCollection</a> *p_parameters)</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;{</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    assert(p_parameters &amp;&amp; p_parameters-&gt;<a class="code" href="namespacehebench_1_1APIBridge.html#a73fa7d634cf14884298d192d40359672">pack_count</a> &gt; 0 &amp;&amp; p_parameters-&gt;<a class="code" href="namespacehebench_1_1APIBridge.html#a43bea41a80b789b123953310e91e2d42">p_data_packs</a>);</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; </div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    assert(p_parameters-&gt;<a class="code" href="namespacehebench_1_1APIBridge.html#a73fa7d634cf14884298d192d40359672">pack_count</a> == 1);</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160; </div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPack">hebench::APIBridge::DataPack</a> &amp;param_pack = p_parameters-&gt;<a class="code" href="namespacehebench_1_1APIBridge.html#a43bea41a80b789b123953310e91e2d42">p_data_packs</a>[0];</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160; </div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">if</span> (param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a> != this-&gt;getDescriptor().cat_params.offline.data_count[param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a>])</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    {</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        std::stringstream ss;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;Unexpected number of input samples for operation parameter &quot;</span> &lt;&lt; param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;           &lt;&lt; <span class="stringliteral">&quot;. Expected &quot;</span> &lt;&lt; this-&gt;getDescriptor().cat_params.offline.data_count[param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a>]</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;           &lt;&lt; <span class="stringliteral">&quot;, but &quot;</span> &lt;&lt; <a class="code" href="namespacehebench_1_1ReportGen.html#a3719b248760816f6342f9f769d4ac2f5">std::to_string</a>(param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a>) &lt;&lt; <span class="stringliteral">&quot; received.&quot;</span>;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(ss.str()));</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    }</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160; </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    std::vector&lt;std::vector&lt;std::int64_t&gt;&gt; clear_param(param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a>);</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160; </div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keywordflow">for</span> (std::size_t sample_i = 0; sample_i &lt; clear_param.size(); ++sample_i)</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    {</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::NativeDataBuffer</a> &amp;native_sample = param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#adec71d611d0a215a74548000bae9aeff">p_buffers</a>[sample_i];</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keyword">const</span> std::int64_t *start_pt                              = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::int64_t *<span class="keyword">&gt;</span>(native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#aaa0145d02cf5ae07a0fa583b5be8de47">p</a>);</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keyword">const</span> std::int64_t *end_pt                                = start_pt + native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#a9ef01b822fa75f3841657abbed013c01">size</a> / <span class="keyword">sizeof</span>(std::int64_t);</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        clear_param[sample_i]                                     = std::vector&lt;std::int64_t&gt;(start_pt, end_pt);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160; </div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    std::vector&lt;lbcrypto::Plaintext&gt; encoded = m_p_workload-&gt;encodeVector(clear_param);</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    InternalParam&lt;lbcrypto::Plaintext&gt; retval;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    retval.samples        = std::move(encoded);</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    retval.param_position = param_pack.<a class="code" href="namespacehebench_1_1APIBridge.html#aa570c2b9dd82ecea6967aaaac4f83149">param_position</a>;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    retval.tag            = InternalParamInfo::tagPlaintext;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160; </div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">return</span> this-&gt;getEngine().template createHandle&lt;decltype(retval)&gt;(</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="keyword">sizeof</span>(lbcrypto::Plaintext) * retval.samples.size(), <span class="comment">// size (arbitrary for our usage if we need to)</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        retval.tag, <span class="comment">// extra tags</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        std::move(retval)); <span class="comment">// constructor parameters</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment"></span>}</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a43bea41a80b789b123953310e91e2d42"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a43bea41a80b789b123953310e91e2d42">hebench::APIBridge::DataPackCollection::p_data_packs</a></div><div class="ttdeci">DataPack * p_data_packs</div><div class="ttdoc">Collection of data packs.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00625">types.h:625</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a4fc50bea04798d1baf8dbad8359f8f10"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a4fc50bea04798d1baf8dbad8359f8f10">hebench::APIBridge::encode</a></div><div class="ttdeci">ErrorCode encode(Handle h_benchmark, const DataPackCollection *p_parameters, Handle *h_plaintext)</div><div class="ttdoc">Given a pack of parameters in raw, native data format, encodes them into plain text suitable for back...</div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a73fa7d634cf14884298d192d40359672"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a73fa7d634cf14884298d192d40359672">hebench::APIBridge::DataPackCollection::pack_count</a></div><div class="ttdeci">std::uint64_t pack_count</div><div class="ttdoc">Number of data packs in the collection.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00626">types.h:626</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_structhebench_1_1APIBridge_1_1DataPackCollection"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPackCollection">hebench::APIBridge::DataPackCollection</a></div><div class="ttdoc">Defines a collection of data packs.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00623">types.h:624</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md42"></a>
2. encrypt</h2>
<p><b><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html#a91c0d767c7ced9f9cfb2126fb7a73e3e">hebench::cpp::BaseBenchmark::encrypt</a></b> is responsible for receiving the plain text output from <code><a class="el" href="namespacehebench_1_1APIBridge.html#a4fc50bea04798d1baf8dbad8359f8f10" title="Given a pack of parameters in raw, native data format, encodes them into plain text suitable for back...">encode()</a></code> and encrypting it into ciphertext.</p>
<div align="center"> <img src="apibridge_encrypt_diagram.png" alt="" width="700" class="inline"/><br  />
 <span>API Bridge Encrypt flow chart.</span> </div><p>Here we retrieve our internal representation from the opaque handle representing the encoded data:</p>
<div class="fragment"><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="keyword">const</span> InternalParam&lt;lbcrypto::Plaintext&gt; &amp;encoded_parameter =</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        this-&gt;getEngine().template retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Plaintext&gt;&gt;(h_encoded_parameters,</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                                                                                          InternalParamInfo::tagPlaintext);</div>
</div><!-- fragment --><p> We want input to <code><a class="el" href="namespacehebench_1_1APIBridge.html#a0487699ebe2558d978890e5effd1e016" title="Encrypts a plain text into a cipher text.">encrypt()</a></code> to be of type <code>InternalParam&lt;lbcrypto::Plaintext&gt;</code>. It is expected all data returned by all methods feeding into <code><a class="el" href="namespacehebench_1_1APIBridge.html#a0487699ebe2558d978890e5effd1e016" title="Encrypts a plain text into a cipher text.">encrypt()</a></code> return data in this format. This data must be wrapped into an opaque handle with tag <code>InternalParamInfo::tagPlaintext</code>. Note that this is our internal convention, established to facilitate communication among our implementation of the backend methods. Test Harness is not aware of our convention. It will only pass our handles in the order defined by the workload pipeline flow.</p>
<p>Since our internal representation is designed to maintain the input format expected by our original methods, now we just need to call the encryption from the original workflow.</p>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; encrypted = m_p_workload-&gt;encryptVector(encoded_parameter.samples);</div>
</div><!-- fragment --><p> Finally, we wrap our encrypted parameter in our internal representation, hiding it inside an opaque handle to cross the boundary of the API Bridge. This handle will be passed to method <code><a class="el" href="namespacehebench_1_1APIBridge.html#ac4d8486aa63649beac1378e8fa8baf3c" title="Loads the specified data from the local host into the remote backend to use as parameter during a cal...">load()</a></code> in the default pipeline.</p>
<div class="fragment"><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; retval;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    retval.samples        = std::move(encrypted);</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    retval.param_position = encoded_parameter.param_position;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    retval.tag            = InternalParamInfo::tagCiphertext;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160; </div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordflow">return</span> this-&gt;getEngine().template createHandle&lt;decltype(retval)&gt;(</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="keyword">sizeof</span>(lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;) * retval.samples.size(), <span class="comment">// size (arbitrary for our usage if we need to)</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        retval.tag, <span class="comment">// extra tags</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        std::move(retval)); <span class="comment">// constructor parameters</span></div>
</div><!-- fragment --><p> This is the complete listing for our method:</p>
<div class="fragment"><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> <a class="code" href="namespacehebench_1_1APIBridge.html#a0487699ebe2558d978890e5effd1e016">TutorialEltwiseAddBenchmark::encrypt</a>(<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> h_encoded_parameters)</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;{</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="keyword">const</span> InternalParam&lt;lbcrypto::Plaintext&gt; &amp;encoded_parameter =</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        this-&gt;getEngine().template retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Plaintext&gt;&gt;(h_encoded_parameters,</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                                                                                          InternalParamInfo::tagPlaintext);</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160; </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; encrypted = m_p_workload-&gt;encryptVector(encoded_parameter.samples);</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; retval;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    retval.samples        = std::move(encrypted);</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    retval.param_position = encoded_parameter.param_position;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    retval.tag            = InternalParamInfo::tagCiphertext;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160; </div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordflow">return</span> this-&gt;getEngine().template createHandle&lt;decltype(retval)&gt;(</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="keyword">sizeof</span>(lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;) * retval.samples.size(), <span class="comment">// size (arbitrary for our usage if we need to)</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        retval.tag, <span class="comment">// extra tags</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        std::move(retval)); <span class="comment">// constructor parameters</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment"></span>}</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a0487699ebe2558d978890e5effd1e016"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a0487699ebe2558d978890e5effd1e016">hebench::APIBridge::encrypt</a></div><div class="ttdeci">ErrorCode encrypt(Handle h_benchmark, Handle h_plaintext, Handle *h_ciphertext)</div><div class="ttdoc">Encrypts a plain text into a cipher text.</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md43"></a>
3. load</h2>
<p>Method <b><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html#a2520f1f316882d0e6b11c4a84bd438e9">hebench::cpp::BaseBenchmark::load</a></b> has two jobs. The first and foremost is to transfer the data to the location where it will be used during the operation, whether it is a remote server, accelerator hardware, or simply local host. The second job, which is usually bundled with the first, is to rearrange the data, if needed, so that the operation itself is not burdened with unnecessary data manipulation. While most of the data manipulation and layout should have happened during <code><a class="el" href="namespacehebench_1_1APIBridge.html#a4fc50bea04798d1baf8dbad8359f8f10" title="Given a pack of parameters in raw, native data format, encodes them into plain text suitable for back...">encode()</a></code>, any last minute arrangements should be done here.</p>
<div align="center"> <img src="apibridge_load_diagram.png" alt="" width="700" class="inline"/><br  />
 <span>API Bridge Encode flow chart.</span> </div><p>This method will receive all handles resulting from previous calls made to <code><a class="el" href="namespacehebench_1_1APIBridge.html#a4fc50bea04798d1baf8dbad8359f8f10" title="Given a pack of parameters in raw, native data format, encodes them into plain text suitable for back...">encode()</a></code> and <code><a class="el" href="namespacehebench_1_1APIBridge.html#a0487699ebe2558d978890e5effd1e016" title="Encrypts a plain text into a cipher text.">encrypt()</a></code> methods. Based on the workload pipeline flow specified in the documentation we know what we will be receiving in those handles, and it is up to our internal convention to extract our information from the opaque handles and organize it for the operation.</p>
<p>Since, for this example, the data will remain in the local host, we do not need to use any extra functionality to transfer it. We will only arrange the order of the parameters to directly match our original workflow operation into a pair (2-tuple).</p>
<div class="fragment"><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    std::pair&lt;std::vector&lt;lbcrypto::Plaintext&gt;, std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt; params;</div>
</div><!-- fragment --><p> It is important to note that if the input handles are destroyed, the generated output handles should not be affected, according to the documentation specification for API Bridge. Also, it is good practice for a backend to avoid modifying the underlying data contained in input handles. This means, that if we only need to pass the data wrapped in an input handle along as return value, we must either duplicate the handle, or create a copy of the data that will not be modified or destroyed if the original data from the input handle is modified or destroyed. In this case we will duplicate the data. We show the handle duplication in the <code><a class="el" href="namespacehebench_1_1APIBridge.html#a5696b351ec3db4f7f3bc28dfb4ef77f4" title="Retrieves the specified data from the backend.">store()</a></code> method.</p>
<div class="fragment"><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="comment">// We query for the parameter position, and, once found, we create a copy of the data.</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">for</span> (std::size_t handle_i = 0; handle_i &lt; count; ++handle_i)</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    {</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="keyword">const</span> InternalParamInfo &amp;param_info =</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;            this-&gt;getEngine().retrieveFromHandle&lt;InternalParamInfo&gt;(p_local_data[handle_i]);</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        assert(param_info.param_position &lt; TutorialEltwiseAddBenchmarkDescription::ParametersCount);</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160; </div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordflow">switch</span> (param_info.param_position)</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        {</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="keywordflow">case</span> 0:</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        {</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            <span class="keywordflow">if</span> (!params.first.empty())</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(<span class="stringliteral">&quot;Duplicated operation parameter detected in input handle.&quot;</span>),</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                                                 <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            <span class="keyword">const</span> InternalParam&lt;lbcrypto::Plaintext&gt; &amp;internal_param =</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Plaintext&gt;&gt;(p_local_data[handle_i],</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                                                                                         InternalParamInfo::tagPlaintext);</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            <span class="comment">// create a deep copy of input</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;            params.first = internal_param.samples;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        }</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keywordflow">case</span> 1:</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        {</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            <span class="keywordflow">if</span> (!params.second.empty())</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(<span class="stringliteral">&quot;Duplicated operation parameter detected in input handle.&quot;</span>),</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                                                 <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            <span class="comment">// create a deep copy of input</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keyword">const</span> InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;internal_param =</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt;(p_local_data[handle_i],</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                                                                                                              InternalParamInfo::tagCiphertext);</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="comment">// create a deep copy of input</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            params.second = internal_param.samples;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        }</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        } <span class="comment">// end switch</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    } <span class="comment">// end for</span></div>
</div><!-- fragment --><p> We complete our method, as usual, by wrapping our representation inside an opaque handle to cross the boundary of the API Bridge. This handle will passed to method <code><a class="el" href="namespacehebench_1_1APIBridge.html#a3d07f6b56035cea3fad6fd7005b22de0" title="Performs the workload operation of the benchmark.">operate()</a></code>.</p>
<p>The full listing for our <code><a class="el" href="namespacehebench_1_1APIBridge.html#ac4d8486aa63649beac1378e8fa8baf3c" title="Loads the specified data from the local host into the remote backend to use as parameter during a cal...">load()</a></code> method is below.</p>
<div class="fragment"><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> <a class="code" href="namespacehebench_1_1APIBridge.html#ac4d8486aa63649beac1378e8fa8baf3c">TutorialEltwiseAddBenchmark::load</a>(<span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> *p_local_data, uint64_t count)</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;{</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    assert(count == TutorialEltwiseAddBenchmarkDescription::ParametersCount);</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160; </div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    std::pair&lt;std::vector&lt;lbcrypto::Plaintext&gt;, std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt; params;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160; </div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="comment">// We query for the parameter position, and, once found, we create a copy of the data.</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">for</span> (std::size_t handle_i = 0; handle_i &lt; count; ++handle_i)</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    {</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="keyword">const</span> InternalParamInfo &amp;param_info =</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;            this-&gt;getEngine().retrieveFromHandle&lt;InternalParamInfo&gt;(p_local_data[handle_i]);</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        assert(param_info.param_position &lt; TutorialEltwiseAddBenchmarkDescription::ParametersCount);</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160; </div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordflow">switch</span> (param_info.param_position)</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        {</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="keywordflow">case</span> 0:</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        {</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            <span class="keywordflow">if</span> (!params.first.empty())</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(<span class="stringliteral">&quot;Duplicated operation parameter detected in input handle.&quot;</span>),</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                                                 <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            <span class="keyword">const</span> InternalParam&lt;lbcrypto::Plaintext&gt; &amp;internal_param =</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Plaintext&gt;&gt;(p_local_data[handle_i],</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                                                                                         InternalParamInfo::tagPlaintext);</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            <span class="comment">// create a deep copy of input</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;            params.first = internal_param.samples;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        }</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keywordflow">case</span> 1:</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        {</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            <span class="keywordflow">if</span> (!params.second.empty())</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(<span class="stringliteral">&quot;Duplicated operation parameter detected in input handle.&quot;</span>),</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                                                 <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            <span class="comment">// create a deep copy of input</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keyword">const</span> InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;internal_param =</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt;(p_local_data[handle_i],</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                                                                                                              InternalParamInfo::tagCiphertext);</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="comment">// create a deep copy of input</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            params.second = internal_param.samples;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        }</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        } <span class="comment">// end switch</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    } <span class="comment">// end for</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="keywordflow">return</span> this-&gt;getEngine().template createHandle&lt;decltype(params)&gt;(</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        <span class="keyword">sizeof</span>(params), <span class="comment">// size (arbitrary for our usage if we need to)</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        InternalParamInfo::tagPlaintext | InternalParamInfo::tagCiphertext, <span class="comment">// extra tags</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        std::move(params)); <span class="comment">// move to avoid extra copy</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment"></span>}</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_ac4d8486aa63649beac1378e8fa8baf3c"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#ac4d8486aa63649beac1378e8fa8baf3c">hebench::APIBridge::load</a></div><div class="ttdeci">ErrorCode load(Handle h_benchmark, const Handle *h_local_packed_params, std::uint64_t local_count, Handle *h_remote)</div><div class="ttdoc">Loads the specified data from the local host into the remote backend to use as parameter during a cal...</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md44"></a>
4. operate</h2>
<p><b><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html#af23f28670d8cdedb9b910c8812814b39">hebench::cpp::BaseBenchmark::operate</a></b> is expected to perform the benchmark operation on the provided combination of encrypted and plain text input data.</p>
<div align="center"> <img src="apibridge_operate_diagram.png" alt="" width="700" class="inline"/><br  />
 <span>API Bridge Encode flow chart.</span> </div><p>In practice, <code><a class="el" href="namespacehebench_1_1APIBridge.html#a3d07f6b56035cea3fad6fd7005b22de0" title="Performs the workload operation of the benchmark.">operate()</a></code> should perform as fast as possible. Also, it should never return until all the results for the requested operation are available on the remote host or device and ready for retrieval from the local host.</p>
<p>To start, we obtain our internal input representation from the opaque input handle. This is the handle returned by method <code><a class="el" href="namespacehebench_1_1APIBridge.html#ac4d8486aa63649beac1378e8fa8baf3c" title="Loads the specified data from the local host into the remote backend to use as parameter during a cal...">load()</a></code>.</p>
<div class="fragment"><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keyword">const</span> std::pair&lt;std::vector&lt;lbcrypto::Plaintext&gt;, std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt; &amp;params =</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        this-&gt;getEngine().retrieveFromHandle&lt;std::pair&lt;std::vector&lt;lbcrypto::Plaintext&gt;, std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt;&gt;(</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;            h_remote_packed, InternalParamInfo::tagCiphertext | InternalParamInfo::tagPlaintext);</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160; </div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="comment">// Looks familiar?</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keyword">const</span> std::vector&lt;lbcrypto::Plaintext&gt; &amp;A                      = params.first;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keyword">const</span> std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;B = params.second;</div>
</div><!-- fragment --><p> Input data for the operation has been packed into a single handle by method <code><a class="el" href="namespacehebench_1_1APIBridge.html#ac4d8486aa63649beac1378e8fa8baf3c" title="Loads the specified data from the local host into the remote backend to use as parameter during a cal...">load()</a></code>. Usually, all of the data samples supplied by Test Harness is encrypted and/or encoded. Indexers are used by Test Harness to point to a portion of input samples to use for the operation, requesting the backend to operate on a subset of the input instead of the complete dataset.</p>
<p>Note that, unless otherwise specified, in offline mode the complete dataset is used, and thus, needing to use the indexers is rare.</p>
<p>In this tutorial, the backend does not support operating on subsets of the dataset. In the following code, we simply validate the indexers and move on. However, support is not difficult to add in this scenario using spans to point to portions of the input dataset. It is left as an exercise to the reader.</p>
<div class="fragment"><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    std::array&lt;std::size_t, TutorialEltwiseAddBenchmarkDescription::ParametersCount&gt; param_size;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    param_size[0]               = A.size();</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    param_size[1]               = B.size();</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    std::uint64_t results_count = 1;</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    <span class="keywordflow">for</span> (std::size_t param_i = 0; param_i &lt; TutorialEltwiseAddBenchmarkDescription::ParametersCount; ++param_i)</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keywordflow">if</span> (p_param_indexers[param_i].value_index &gt;= param_size[param_i])</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        {</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            std::stringstream ss;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            ss &lt;&lt; <span class="stringliteral">&quot;Invalid parameter indexer for operation parameter &quot;</span> &lt;&lt; param_i &lt;&lt; <span class="stringliteral">&quot;. Expected index in range [0, &quot;</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;               &lt;&lt; param_size[param_i] &lt;&lt; <span class="stringliteral">&quot;), but &quot;</span> &lt;&lt; p_param_indexers[param_i].value_index &lt;&lt; <span class="stringliteral">&quot; received.&quot;</span>;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(ss.str()),</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                                             <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        }</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p_param_indexers[param_i].value_index + p_param_indexers[param_i].batch_size &gt; param_size[param_i])</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            std::stringstream ss;</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            ss &lt;&lt; <span class="stringliteral">&quot;Invalid parameter indexer for operation parameter &quot;</span> &lt;&lt; param_i &lt;&lt; <span class="stringliteral">&quot;. Expected batch size in range [1, &quot;</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;               &lt;&lt; param_size[param_i] - p_param_indexers[param_i].value_index &lt;&lt; <span class="stringliteral">&quot;], but &quot;</span> &lt;&lt; p_param_indexers[param_i].batch_size &lt;&lt; <span class="stringliteral">&quot; received.&quot;</span>;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(ss.str()),</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                                             <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        results_count *= p_param_indexers[param_i].batch_size; <span class="comment">// count the number of results expected</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    }</div>
</div><!-- fragment --><p> Since we obtained the inputs for our operation in the correct format, next we pass them to our original workflow.</p>
<div class="fragment"><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; result = m_p_workload-&gt;eltwiseadd(A, B);</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    assert(result.size() == results_count);</div>
</div><!-- fragment --><p> As a side note: if operate is executing on an external device that requires some sort of data streaming, this can be mimicked in offline mode as follows:</p>
<ol type="1">
<li>Load first chunk of data during loading phase.</li>
<li>(in parallel) Operate on current chunk of data. (in parallel) If more data is available, stream next chunk of data from host into remote.</li>
<li>If more data is available, go to ii.</li>
<li>Wait for all ongoing operations to complete.</li>
</ol>
<p>Finally, we wrap the result in our internal representation, and hide it inside an opaque handle to cross the boundary of the API Bridge. This handle will be passed to method <code><a class="el" href="namespacehebench_1_1APIBridge.html#a5696b351ec3db4f7f3bc28dfb4ef77f4" title="Retrieves the specified data from the backend.">store()</a></code> in the default pipeline.</p>
<p>Full listing of the <code><a class="el" href="namespacehebench_1_1APIBridge.html#a3d07f6b56035cea3fad6fd7005b22de0" title="Performs the workload operation of the benchmark.">operate()</a></code> method follows.</p>
<div class="fragment"><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> <a class="code" href="namespacehebench_1_1APIBridge.html#a3d07f6b56035cea3fad6fd7005b22de0">TutorialEltwiseAddBenchmark::operate</a>(<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> h_remote_packed,</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                                                                <span class="keyword">const</span> <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1ParameterIndexer">hebench::APIBridge::ParameterIndexer</a> *p_param_indexers)</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;{</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keyword">const</span> std::pair&lt;std::vector&lt;lbcrypto::Plaintext&gt;, std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt; &amp;params =</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        this-&gt;getEngine().retrieveFromHandle&lt;std::pair&lt;std::vector&lt;lbcrypto::Plaintext&gt;, std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt;&gt;(</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;            h_remote_packed, InternalParamInfo::tagCiphertext | InternalParamInfo::tagPlaintext);</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160; </div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="comment">// Looks familiar?</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keyword">const</span> std::vector&lt;lbcrypto::Plaintext&gt; &amp;A                      = params.first;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keyword">const</span> std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;B = params.second;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160; </div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    std::array&lt;std::size_t, TutorialEltwiseAddBenchmarkDescription::ParametersCount&gt; param_size;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    param_size[0]               = A.size();</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    param_size[1]               = B.size();</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    std::uint64_t results_count = 1;</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    <span class="keywordflow">for</span> (std::size_t param_i = 0; param_i &lt; TutorialEltwiseAddBenchmarkDescription::ParametersCount; ++param_i)</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keywordflow">if</span> (p_param_indexers[param_i].value_index &gt;= param_size[param_i])</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        {</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            std::stringstream ss;</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            ss &lt;&lt; <span class="stringliteral">&quot;Invalid parameter indexer for operation parameter &quot;</span> &lt;&lt; param_i &lt;&lt; <span class="stringliteral">&quot;. Expected index in range [0, &quot;</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;               &lt;&lt; param_size[param_i] &lt;&lt; <span class="stringliteral">&quot;), but &quot;</span> &lt;&lt; p_param_indexers[param_i].<a class="code" href="namespacehebench_1_1APIBridge.html#a520b821a574e16cbf8dda44e2847462a">value_index</a> &lt;&lt; <span class="stringliteral">&quot; received.&quot;</span>;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(ss.str()),</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                                             <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        }</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p_param_indexers[param_i].value_index + p_param_indexers[param_i].batch_size &gt; param_size[param_i])</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            std::stringstream ss;</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            ss &lt;&lt; <span class="stringliteral">&quot;Invalid parameter indexer for operation parameter &quot;</span> &lt;&lt; param_i &lt;&lt; <span class="stringliteral">&quot;. Expected batch size in range [1, &quot;</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;               &lt;&lt; param_size[param_i] - p_param_indexers[param_i].<a class="code" href="namespacehebench_1_1APIBridge.html#a520b821a574e16cbf8dda44e2847462a">value_index</a> &lt;&lt; <span class="stringliteral">&quot;], but &quot;</span> &lt;&lt; p_param_indexers[param_i].<a class="code" href="namespacehebench_1_1APIBridge.html#a9508cbed71cb5d78808d2e6e513020b9">batch_size</a> &lt;&lt; <span class="stringliteral">&quot; received.&quot;</span>;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classhebench_1_1cpp_1_1HEBenchError.html">hebench::cpp::HEBenchError</a>(<a class="code" href="error__handling_8hpp.html#a9d8a8027ac0dfd443d0b8d000f86c30d">HEBERROR_MSG_CLASS</a>(ss.str()),</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                                             <a class="code" href="types_8h.html#abba732801d5a4a4d7608505eebddf434">HEBENCH_ECODE_INVALID_ARGS</a>);</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        results_count *= p_param_indexers[param_i].<a class="code" href="namespacehebench_1_1APIBridge.html#a9508cbed71cb5d78808d2e6e513020b9">batch_size</a>; <span class="comment">// count the number of results expected</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    }</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160; </div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    std::vector&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; result = m_p_workload-&gt;eltwiseadd(A, B);</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    assert(result.size() == results_count);</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160; </div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="comment">// Finally, we wrap the result in our internal representation.</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; retval;</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    retval.samples        = std::move(result);</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    retval.param_position = 0; <span class="comment">// position of this result component inside the result tuple.</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    retval.tag            = InternalParamInfo::tagCiphertext;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160; </div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <span class="comment">// Hide our representation inside an opaque handle to cross the boundary of the API Bridge.</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="comment">// This handle will be passed to method `store()` in the default pipeline.</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="keywordflow">return</span> this-&gt;getEngine().template createHandle&lt;decltype(retval)&gt;(</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        <span class="keyword">sizeof</span>(lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;) * retval.samples.size(), <span class="comment">// size (arbitrary for our usage if we need to)</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        retval.tag, <span class="comment">// extra tags</span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        std::move(retval)); <span class="comment">// move to avoid extra copies</span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="comment"></span>}</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a3d07f6b56035cea3fad6fd7005b22de0"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a3d07f6b56035cea3fad6fd7005b22de0">hebench::APIBridge::operate</a></div><div class="ttdeci">ErrorCode operate(Handle h_benchmark, Handle h_remote_packed_params, const ParameterIndexer *p_param_indexers, uint64_t indexers_count, Handle *h_remote_output)</div><div class="ttdoc">Performs the workload operation of the benchmark.</div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a520b821a574e16cbf8dda44e2847462a"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a520b821a574e16cbf8dda44e2847462a">hebench::APIBridge::ParameterIndexer::value_index</a></div><div class="ttdeci">std::uint64_t value_index</div><div class="ttdoc">Index of parameter value inside the data pack.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00651">types.h:651</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a9508cbed71cb5d78808d2e6e513020b9"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a9508cbed71cb5d78808d2e6e513020b9">hebench::APIBridge::ParameterIndexer::batch_size</a></div><div class="ttdeci">std::uint64_t batch_size</div><div class="ttdoc">Number of values to use, starting from index.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00652">types.h:652</a></div></div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_structhebench_1_1APIBridge_1_1ParameterIndexer"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1ParameterIndexer">hebench::APIBridge::ParameterIndexer</a></div><div class="ttdoc">Indexes a DataPack.</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00649">types.h:650</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md45"></a>
5. store</h2>
<p><b><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html#a49e7f7508f8cbbcc1e0895b13cc356e7">hebench::cpp::BaseBenchmark::store</a></b> is responsible for copying results back from our remote device into the local host.</p>
<div align="center"> <img src="apibridge_store_diagram.png" alt="" width="700" class="inline"/><br  />
 <span>API Bridge Encode flow chart.</span> </div><p>We are on the downward slope now. We must store, decrypt, and decode the results of the operation.</p>
<p>The input handle for method <code><a class="el" href="namespacehebench_1_1APIBridge.html#a5696b351ec3db4f7f3bc28dfb4ef77f4" title="Retrieves the specified data from the backend.">store()</a></code> is the handle returned by operate. In a backend where the operation occurs on a remote device (server, hardware accelerator, etc.) the result of the operation remains on the remote after completion. The job of this method is to transfer that result from remote into the local host for the rest of the pipeline.</p>
<p>As per specification of API Bridge, any extra handles should be padded with zeroes. So, we take care of that first to avoid extra work later.</p>
<div class="fragment"><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        std::memset(p_local_data, 0, <span class="keyword">sizeof</span>(<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a>) * count);</div>
</div><!-- fragment --><p> Since the host and remote are the same for this example, we do not need to perform any retrieval operations. We will just duplicate the handle to ensure that if the input handle is destroyed, the resulting handle remains.</p>
<div class="fragment"><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        p_local_data[0] = this-&gt;getEngine().duplicateHandle(h_remote_data,</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                                                            InternalParamInfo::tagCiphertext); <span class="comment">// validate that we are operating on the correct handle</span></div>
</div><!-- fragment --><p> Note that handle duplication does not perform a deep copy of the underlying data. Both, the original and duplicated handle will refer to the same internal data and modifying one will effectively reflect the changes in the other. While the specification calls for persistence of results after destruction of the input handles, it does not mention consistency of the data. Such consistency is backend dependent. To ensure data consistency, though, it is good practice for a backend to not modify the underlying data of an input handle.</p>
<p>This duplicated handle will be passed as input to the <code><a class="el" href="namespacehebench_1_1APIBridge.html#a563432d24c94d7b3fdb902a9d2c1e1c3" title="Decrypts a cipher text into corresponding plain text.">decrypt()</a></code> method in the default pipeline.</p>
<p>The full listing for this method is:</p>
<div class="fragment"><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacehebench_1_1APIBridge.html#a5696b351ec3db4f7f3bc28dfb4ef77f4">TutorialEltwiseAddBenchmark::store</a>(<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> h_remote_data,</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                                        <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> *p_local_data, std::uint64_t count)</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;{</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="keywordflow">if</span> (count &gt; 0)</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        std::memset(p_local_data, 0, <span class="keyword">sizeof</span>(<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a>) * count);</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160; </div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        p_local_data[0] = this-&gt;getEngine().duplicateHandle(h_remote_data,</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                                                            InternalParamInfo::tagCiphertext); <span class="comment">// validate that we are operating on the correct handle</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="comment"></span>    }</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;}</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_a5696b351ec3db4f7f3bc28dfb4ef77f4"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#a5696b351ec3db4f7f3bc28dfb4ef77f4">hebench::APIBridge::store</a></div><div class="ttdeci">ErrorCode store(Handle h_benchmark, Handle h_remote, Handle *h_local_packed_params, std::uint64_t local_count)</div><div class="ttdoc">Retrieves the specified data from the backend.</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md46"></a>
6. decrypt</h2>
<p><b><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html#a2b608a46ac892e31a1f5841f007e7ce7">hebench::cpp::BaseBenchmark::decrypt</a></b> receives result ciphertexts output from <code><a class="el" href="namespacehebench_1_1APIBridge.html#a5696b351ec3db4f7f3bc28dfb4ef77f4" title="Retrieves the specified data from the backend.">store()</a></code> and decrypts them into plaintexts.</p>
<div align="center"> <img src="apibridge_decrypt_diagram.png" alt="" width="700" class="inline"/><br  />
 <span>API Bridge Encode flow chart.</span> </div><p>As before, we retrieve our internal representation from the input handle. This is coming from <code><a class="el" href="namespacehebench_1_1APIBridge.html#a5696b351ec3db4f7f3bc28dfb4ef77f4" title="Retrieves the specified data from the backend.">store()</a></code> in the default pipeline.</p>
<div class="fragment"><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keyword">const</span> InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;encrypted_data =</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt;(h_encrypted_data, InternalParamInfo::tagCiphertext);</div>
</div><!-- fragment --><p> Next, we use our original workload decryption.</p>
<div class="fragment"><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    std::vector&lt;lbcrypto::Plaintext&gt; encoded_data_samples = m_p_workload-&gt;decryptResult(encrypted_data.samples);</div>
</div><!-- fragment --><p> And we finish by wrapping the decrypted data in our internal representation and returning it inside an opaque handle through the API Bridge. This handle will be passed to method <code><a class="el" href="namespacehebench_1_1APIBridge.html#ad42002b907afda2357a5c28406b30bf5" title="Decodes plaintext data into the appropriate raw, native format.">decode()</a></code> in the default pipeline.</p>
<p>Full listing of this method follows.</p>
<div class="fragment"><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> <a class="code" href="namespacehebench_1_1APIBridge.html#a563432d24c94d7b3fdb902a9d2c1e1c3">TutorialEltwiseAddBenchmark::decrypt</a>(<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> h_encrypted_data)</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;{</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keyword">const</span> InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt; &amp;encrypted_data =</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Ciphertext&lt;lbcrypto::DCRTPoly&gt;&gt;&gt;(h_encrypted_data, InternalParamInfo::tagCiphertext);</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160; </div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    assert(encrypted_data.param_position == 0);</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160; </div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    std::vector&lt;lbcrypto::Plaintext&gt; encoded_data_samples = m_p_workload-&gt;decryptResult(encrypted_data.samples);</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160; </div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    InternalParam&lt;lbcrypto::Plaintext&gt; retval;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    retval.samples        = std::move(encoded_data_samples);</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    retval.param_position = encrypted_data.param_position;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    retval.tag            = InternalParamInfo::tagPlaintext;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160; </div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="keywordflow">return</span> this-&gt;getEngine().template createHandle&lt;decltype(retval)&gt;(</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        <span class="keyword">sizeof</span>(lbcrypto::Plaintext) * retval.samples.size(), <span class="comment">// size (arbitrary for our usage if we need to)</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        retval.tag, <span class="comment">// extra tags</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        std::move(retval)); <span class="comment">// move to avoid copy</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment"></span>}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md47"></a>
7 decode</h2>
<p><b><a class="el" href="classhebench_1_1cpp_1_1BaseBenchmark.html#aa29ad5e51a86ccbec553a13fa5a762a7">hebench::cpp::BaseBenchmark::decode</a></b> is responsible for receiving encoded result data and writing its decoded form back to the output buffer.</p>
<div align="center"> <img src="apibridge_decode_diagram.png" alt="" width="700" class="inline"/><br  />
 <span>API Bridge Encode flow chart.</span> </div><p>Here we decode the data from the operation result and arrange it into the format expected by Test Harness for validation. We touch upon some specification details regarding possible excess or insufficient data.</p>
<p>As usual, we retrieve our internal representation from the input handle. This handle comes from method <code><a class="el" href="namespacehebench_1_1APIBridge.html#a563432d24c94d7b3fdb902a9d2c1e1c3" title="Decrypts a cipher text into corresponding plain text.">decrypt()</a></code> according to the default pipeline.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keyword">const</span> InternalParam&lt;lbcrypto::Plaintext&gt; &amp;encoded_data =</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Plaintext&gt;&gt;(h_encoded_data, InternalParamInfo::tagPlaintext);</div>
</div><!-- fragment --><p> Having our internal representation, we call the original workload version to decode our result.</p>
<div class="fragment"><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    std::vector&lt;std::vector&lt;std::int64_t&gt;&gt; clear_result = m_p_workload-&gt;decodeResult(encoded_data.samples);</div>
</div><!-- fragment --><p> Finally, we rearrange the result clear text in the format expected by Test Harness, respecting the specifications.</p>
<p>The <code><a class="el" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPackCollection" title="Defines a collection of data packs.">hebench::APIBridge::DataPackCollection</a>*</code> parameter points to pre-allocated memory into which the decoded results must be written. The exact size, format, data type, etc. is detailed in the workload description which for this example is <a class="el" href="elementwise_add.html">Vector Element-wise Addition Workload</a> .</p>
<p>We are returning the result, so, we find the data pack corresponding to this result component from the pre-allocated buffers. If we had more than one component, we would loop on the components and decode each. This method will throw an exception if the requested component is missing from the data packs passed by Test Harness into <code><a class="el" href="namespacehebench_1_1APIBridge.html#ad42002b907afda2357a5c28406b30bf5" title="Decodes plaintext data into the appropriate raw, native format.">decode()</a></code> (note that this should not happen in a default workload pipeline).</p>
<div class="fragment"><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPack">hebench::APIBridge::DataPack</a> &amp;native_datapack = this-&gt;findDataPack(*p_native, encoded_data.param_position);</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160; </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    std::uint64_t min_sample_count = std::min(native_datapack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a>, clear_result.size());</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">for</span> (std::uint64_t sample_i = 0; sample_i &lt; min_sample_count; ++sample_i)</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    {</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        <span class="comment">// alias the samples</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::NativeDataBuffer</a> &amp;native_sample = native_datapack.<a class="code" href="namespacehebench_1_1APIBridge.html#adec71d611d0a215a74548000bae9aeff">p_buffers</a>[sample_i];</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="comment">// copy as much as possible</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keyword">const</span> std::vector&lt;std::int64_t&gt; &amp;decoded = clear_result[sample_i];</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        std::uint64_t min_size                   = std::min(decoded.size(), native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#a9ef01b822fa75f3841657abbed013c01">size</a> / <span class="keyword">sizeof</span>(std::int64_t));</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        std::copy_n(decoded.begin(), min_size,</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                    <span class="keyword">reinterpret_cast&lt;</span>std::int64_t *<span class="keyword">&gt;</span>(native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#aaa0145d02cf5ae07a0fa583b5be8de47">p</a>));</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    }</div>
</div><!-- fragment --><p> According to specification, we must decode as much data as possible, where any excess encoded data that won't fit into the pre-allocated native buffers shall be ignored. If the buffers fit more data than we have, we only set as much as we have and do not touch the excess space.</p>
<p>Find the complete listing for this method next.</p>
<div class="fragment"><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacehebench_1_1APIBridge.html#ad42002b907afda2357a5c28406b30bf5">TutorialEltwiseAddBenchmark::decode</a>(<a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::Handle</a> h_encoded_data,</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                                         <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPackCollection">hebench::APIBridge::DataPackCollection</a> *p_native)</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;{</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    assert(p_native &amp;&amp; p_native-&gt;<a class="code" href="namespacehebench_1_1APIBridge.html#a43bea41a80b789b123953310e91e2d42">p_data_packs</a> &amp;&amp; p_native-&gt;<a class="code" href="namespacehebench_1_1APIBridge.html#a73fa7d634cf14884298d192d40359672">pack_count</a> &gt; 0);</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160; </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keyword">const</span> InternalParam&lt;lbcrypto::Plaintext&gt; &amp;encoded_data =</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        this-&gt;getEngine().retrieveFromHandle&lt;InternalParam&lt;lbcrypto::Plaintext&gt;&gt;(h_encoded_data, InternalParamInfo::tagPlaintext);</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160; </div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    std::vector&lt;std::vector&lt;std::int64_t&gt;&gt; clear_result = m_p_workload-&gt;decodeResult(encoded_data.samples);</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160; </div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1DataPack">hebench::APIBridge::DataPack</a> &amp;native_datapack = this-&gt;findDataPack(*p_native, encoded_data.param_position);</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160; </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    std::uint64_t min_sample_count = std::min(native_datapack.<a class="code" href="namespacehebench_1_1APIBridge.html#acf775f3fb5a78d09c32232b1a984587d">buffer_count</a>, clear_result.size());</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">for</span> (std::uint64_t sample_i = 0; sample_i &lt; min_sample_count; ++sample_i)</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    {</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        <span class="comment">// alias the samples</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <a class="code" href="namespacehebench_1_1APIBridge.html#structhebench_1_1APIBridge_1_1__FlexibleData">hebench::APIBridge::NativeDataBuffer</a> &amp;native_sample = native_datapack.<a class="code" href="namespacehebench_1_1APIBridge.html#adec71d611d0a215a74548000bae9aeff">p_buffers</a>[sample_i];</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="comment">// copy as much as possible</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keyword">const</span> std::vector&lt;std::int64_t&gt; &amp;decoded = clear_result[sample_i];</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        std::uint64_t min_size                   = std::min(decoded.size(), native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#a9ef01b822fa75f3841657abbed013c01">size</a> / <span class="keyword">sizeof</span>(std::int64_t));</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        std::copy_n(decoded.begin(), min_size,</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                    <span class="keyword">reinterpret_cast&lt;</span>std::int64_t *<span class="keyword">&gt;</span>(native_sample.<a class="code" href="namespacehebench_1_1APIBridge.html#aaa0145d02cf5ae07a0fa583b5be8de47">p</a>));</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;}</div>
<div class="ttc" id="anamespacehebench_1_1APIBridge_html_ad42002b907afda2357a5c28406b30bf5"><div class="ttname"><a href="namespacehebench_1_1APIBridge.html#ad42002b907afda2357a5c28406b30bf5">hebench::APIBridge::decode</a></div><div class="ttdeci">ErrorCode decode(Handle h_benchmark, Handle h_plaintext, DataPackCollection *p_native)</div><div class="ttdoc">Decodes plaintext data into the appropriate raw, native format.</div></div>
</div><!-- fragment --> <hr  />
<p> At this point, the default pipeline is completed. Test Harness takes over, performs validation of the result, and, if result is correct, generates the benchmark reports.</p>
<p>Make sure to perform appropriate cleanup in the destructor of your classes. Test Harness will request destruction of resources when they are no longer needed. </p><hr  />
<h1><a class="anchor" id="autotoc_md48"></a>
Tutorial steps</h1>
<p><a class="el" href="simple_cpp_example_palisade.html#md_docsrc_examples_backend_tutorials_palisade_backend_tutorial_palisade">Tutorial Home</a><br  />
 <a class="el" href="be_tutorial_preparation_palisade.html#md_docsrc_examples_backend_tutorials_palisade_backend_tutorial_preparation_palisade">Preparation</a><br  />
 <a class="el" href="be_tutorial_init_palisade.html#md_docsrc_examples_backend_tutorials_palisade_backend_tutorial_init_palisade">Engine Initialization and Benchmark Description</a><br  />
 <b>Benchmark Implementation</b><br  />
 <a class="el" href="be_tutorial_files_palisade.html#md_docsrc_examples_backend_tutorials_palisade_backend_tutorial_files_palisade">File References</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
